### 1. Определение двудольного графа
Граф называется двудольным, если его можно разбить на две непересекающиеся подмножества вершин \( U \) и \( V \) так, что каждое ребро соединяет вершину из \( U \) с вершиной из \( V \). В двудольном графе нет рёбер, соединяющих вершины внутри одного подмножества.

### 2. Понятие паросочетания
Паросочетание в графе — это набор рёбер, таких что ни одно два рёбра не соединяют одну и ту же вершину. Максимальное паросочетание — это паросочетание, в котором количество рёбер максимально.

### 3. Алгоритмы поиска паросочетаний

1. **Алгоритм Форда-Фалкерсона**: основан на методе увеличения потока. Ищет максимальное паросочетание, представляя его как задачу о максимальном потоке в сети.
   - **Свойства**: эффективен для разреженных графов, использует поиск в глубину или ширину для поиска увеличивающих путей.
   
2. **Алгоритм Хопкрофта–Карпа**: оптимизированный вариант алгоритма Форда-Фалкерсона, который уменьшает количество увеличивающих путей.
   - **Свойства**: работает быстрее, чем обычный алгоритм, за счет использования чередующихся путей.
   
3. **Алгоритм Диница**: также основан на потоке, использует уровневые графы для оптимизации поиска увеличивающих путей.
   - **Свойства**: хорошо работает на больших графах, эффективен для многопоточных задач.


Алгоритм Форда-Фалкерсона используется для нахождения максимального потока в сети, что эквивалентно поиску наибольшего паросочетания в двудольных графах. Этот алгоритм основан на концепции поиска увеличивающих путей и может быть реализован с использованием обхода в ширину (BFS) или обхода в глубину (DFS).

## Шаги алгоритма Форда-Фалкерсон

1. **Инициализация**
   - Создаем ориентированный граф из двудольного графа, где каждое ребро имеет пропускную способность, равную 1 (в двудольном графе ребра представляют возможные пары).
   - Устанавливаем начальный поток (max flow) равным 0.

2. **Поиск увеличивающего пути**
   - Используем BFS для поиска пути из источника \(s\) в сток \(t\).
   - Если путь найден, запоминаем его в массиве `parent`, который будет содержать информацию о предыдущем узле для каждого узла в пути.

3. **Обновление потока**
   - Для найденного увеличивающего пути находим минимальную пропускную способность.
   - Увеличиваем поток вдоль этого пути на найденное значение.
   - Обновляем остаточные ребра в графе:
     - Увеличиваем пропускную способность прямых ребер.
     - Уменьшаем пропускную способность обратных ребер.

4. **Повторение**
   - Повторяем шаги 2 и 3 до тех пор, пока не удастся найти увеличивающий путь.

5. **Возврат результата**
   - После завершения алгоритма, величина максимального потока равна размеру наибольшего паросочетания в графе.
